syntax = "proto3";

option go_package = "chainguard.dev/sdk/proto/platform/tenant/v1";
option java_multiple_files = true;
option java_package = "dev.chainguard.sdk.platform.tenant.v1";
option java_outer_classname = "PlatformTenantSbomProto";

package chainguard.platform.tenant;

import "google/protobuf/timestamp.proto";
import "annotations/auth.proto";
import "platform/common/v1/uidp.platform.proto";

service Sboms {
    rpc List(Sbom2Filter) returns (Sbom2List) {
    option (chainguard.annotations.iam) = {
      enabled: {
        capabilities: [CAP_TENANT_SBOMS_LIST]
        unscoped: true
      }
    };
    }
  }

// Sbom represents a normalized SBOM that we have ingested into our datastore.
// They are linked to Signatures via ID, as in they are 'children' of Signatures
// There can be multiple of these that we keep.
message Sbom2 {
  // id, The Sbom UIDP at which this Sbom resides in the hierarchy.
  string id = 1;

  // raw_sbom may or may not be useful in the long term, but for now to make
  // progress on this, we'll just yolo and serialize it here.
  bytes raw_sbom = 2;

  ComponentGraph graph = 3;

  // last_seen tracks the timestamp at which this sbom was last seen.
  // TODO(vaikas): Does this really make any sense?
  google.protobuf.Timestamp last_seen = 4;

  // tool holds the name of the tool that produced the SBOM.
  string tool = 5;
  // format holds whether the SBOM is SPDX, CycloneDX, or other.
  string format = 6;
  // generated_at holds when the SBOM was generated.
  google.protobuf.Timestamp generated_at = 7;
  // authors is zero or more authors concatenated.
  string authors = 8;

  // source is where the SBOM came from. For example, we want to know if sbom
  // was generated by us, or ingested.
  Source source = 9;

  // Type
  enum Source {
    UNKNOWN = 0;
    INGESTED = 1;
    GENERATED = 2;
  }
    // Name of the Sbom.
  string name = 10;

  // Short description of the Sbom
  string description = 11;

  // digest of the SBOM when ingested
  optional string digest = 12;
}

message ComponentGraph {
  repeated Node nodes = 1;
  repeated Edge edges = 2;

  message Node {
    oneof typed_node {
      Package2 package = 1;
      File2 file = 2;
    }
  }

  message Edge {
    string subject_id = 1;
    string predicate_id = 2;
    Type type = 3;

    enum Type {
      UNKNOWN = 0;
      DESCRIBES = 1;
      CONTAINS = 2;
      DEPENDS_ON = 3;
      GENERATED_FROM = 4;
      // and so on...; for inspiration, see https://spdx.github.io/spdx-spec/v2.3/relationships-between-SPDX-elements/
    }
  }
}

message Package2 {
  string id = 1;
  string name = 2;
  string version = 3;
  string license = 4;
  string description = 5;
  string purl = 6;
}

message File2 {
   // 3 was used for single type.
  reserved 3;

  string id = 1;
  string name = 2;
  repeated string types = 4;
}

message Sbom2List {
  repeated Sbom2 items = 1;
}

message Sbom2Filter {
  // id is the exact UID of the record.
  string id = 1;

  chainguard.platform.common.UIDPFilter uidp = 2;

  // active_since is the timestamp after which the records should
  // have last been observed in the returned context.
  google.protobuf.Timestamp active_since = 3;
  // include_raw_sbom is a flag to return the raw sbom field in the record.
  bool include_raw_sbom = 4;
}
